pragram solidity ^0.8.0;

import "./interfaces/IERC20.sol";
import "./interfaces/Uniswap.sol";


contract example {
    function zeroxSwap(
    // The `sellTokenAddress` field from the API response.
    address sellToken,
    // The `buyTokenAddress` field from the API response.
    address buyToken,
    // The `allowanceTarget` field from the API response.
    address spender,
    // The `to` field from the API response.
    address payable swapTarget,
    // The `data` field from the API response.
    // It's the encoded data payload that needs to be sent to the 0x Exchange Proxy contract to execute the swap
    bytes calldata swapCallData,

    uint amountIn,
    uint amountOut
  ) external payable {
    // Checks that the swapTarget is actually the address of 0x ExchangeProxy
    require(swapTarget == exchangeProxy, "Target not ExchangeProxy");

    // Give `spender` (0x contract) an infinite allowance to spend the `sellToken`
    // Note that for some tokens (e.g., USDT, KNC), you must first reset any existing allowance to 0
    require(
      IERC20(sellToken).approve(spender, type(uint256).max),
      "allowance error"
    );

    // Track the initial user balance of the buyToken, so we can calculate how much was bought at the end
    // the calculation will be made by subtracting the initial balance from the final balance of the buyToken
    // @dev: this assumes that the msg.sender is the holder of the buyToken, if not, this needs to be changed
    uint256 boughtAmount = IERC20(buyToken).balanceOf(msg.sender);

    // Execute the swap by calling the 0x ExchangeProxy contract
    // Note that the swapCallData is the encoded data payload that needs to be sent to the 0x Exchange Proxy contract to execute the swap
    // The swapCallData is generated by the 0x API and passed to this function as a parameter
    // The swapCallData is generated by the 0x API based on the parameters passed to the API
    (bool success, ) = swapTarget.call{ value: msg.value }(swapCallData);
    require(success, "SWAP_CALL_FAILED");

    // IERC20(sellToken).approve(ROUTER, amountIn);
    // IERC20(buyToken).approve(ROUTER, amountOut);
    // address[] memory path = new address[](2);
    //     path[0] = sellToken;
    //     path[1] = buyToken;
    //   IUniswapV2Router02(ROUTER).swapExactTokensForTokens(
    //         amountIn, 
    //         amountOut, 
    //         path, 
    //         msg.sender, 
    //         block.timestamp
    //     );

    // it checks if there is any unspent protocol fees left in the contract balance resulted of any unspent protocol fees,
    // and if so, it refunds the sender
    // dev: double check if it's necessary, not sure if any unspent fees will be sent to this contract
    if (address(this).balance > 0) {
      (bool success2, ) = msg.sender.call{ value: address(this).balance }("");
      require(success2, "Refund failed");
    }

    // Calculate the amount of `buyToken` bought by subtracting the initial balance from the final balance
    emit BoughtTokens(IERC20(sellToken), IERC20(buyToken), boughtAmount);
    boughtAmount = IERC20(buyToken).balanceOf(address(this));
    // Transfer the bought tokens directly to the msg.sender
    require(
      IERC20(buyToken).transfer(msg.sender, boughtAmount),
      "Transfer failed"
    );
  }
}